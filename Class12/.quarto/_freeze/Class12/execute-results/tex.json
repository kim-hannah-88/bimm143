{
  "hash": "4b58f15e915d2b55cb2c108bc1aa7fe7",
  "result": {
    "markdown": "---\ntitle: \"Class 12: Transcriptomics and the analysis of RNA-Seq data\"\nauthor: Hannah Kim \ndate: 05-12-23\nformat: pdf\n---\n\n\n# Import countData and colData\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounts <- read.csv(\"airway_scaledcounts.csv\", row.names=1)\nmetadata <-  read.csv(\"airway_metadata.csv\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(counts)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                SRR1039508 SRR1039509 SRR1039512 SRR1039513 SRR1039516\nENSG00000000003        723        486        904        445       1170\nENSG00000000005          0          0          0          0          0\nENSG00000000419        467        523        616        371        582\nENSG00000000457        347        258        364        237        318\nENSG00000000460         96         81         73         66        118\nENSG00000000938          0          0          1          0          2\n                SRR1039517 SRR1039520 SRR1039521\nENSG00000000003       1097        806        604\nENSG00000000005          0          0          0\nENSG00000000419        781        417        509\nENSG00000000457        447        330        324\nENSG00000000460         94        102         74\nENSG00000000938          0          0          0\n```\n:::\n\n```{.r .cell-code}\nhead(metadata)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          id     dex celltype     geo_id\n1 SRR1039508 control   N61311 GSM1275862\n2 SRR1039509 treated   N61311 GSM1275863\n3 SRR1039512 control  N052611 GSM1275866\n4 SRR1039513 treated  N052611 GSM1275867\n5 SRR1039516 control  N080611 GSM1275870\n6 SRR1039517 treated  N080611 GSM1275871\n```\n:::\n:::\n\n\n**Q1.** How many genes are in this dataset?\n\n38694\n\n**Q2.** How many 'control' cell lines do we have?\n\n4\n\n# Toy differential gene expression\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Find the sample ids for control samples\ncontrol <- metadata[metadata[,\"dex\"]==\"control\",]\ncontrol.counts <- counts[ ,control$id]\ncontrol.mean <- rowSums( control.counts )/4 \nhead(control.mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nENSG00000000003 ENSG00000000005 ENSG00000000419 ENSG00000000457 ENSG00000000460 \n         900.75            0.00          520.50          339.75           97.25 \nENSG00000000938 \n           0.75 \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#Use these ids to select the columns I want in another table\nmetadata[metadata[,\"dex\"] == \"control\",]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          id     dex celltype     geo_id\n1 SRR1039508 control   N61311 GSM1275862\n3 SRR1039512 control  N052611 GSM1275866\n5 SRR1039516 control  N080611 GSM1275870\n7 SRR1039520 control  N061011 GSM1275874\n```\n:::\n\n```{.r .cell-code}\ncontrol$id\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"SRR1039508\" \"SRR1039512\" \"SRR1039516\" \"SRR1039520\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncontrol.counts <- counts[ ,control$id]\ncontrol.mean <- rowSums( control.counts )/4 \nhead(control.mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nENSG00000000003 ENSG00000000005 ENSG00000000419 ENSG00000000457 ENSG00000000460 \n         900.75            0.00          520.50          339.75           97.25 \nENSG00000000938 \n           0.75 \n```\n:::\n:::\n\n\n**Q3.** How would you make the above code in either approach more robust?\n\nCreate a function that takes the \"treated\" or \"control\" data to calculate the mean so that the code is more simplified and reusable.\n\n**Q4.** Follow the same procedure for the `treated` samples (i.e.Â calculate the mean per gene across drug treated samples and assign to a labeled vector called `treated.mean`)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntreated <- metadata[metadata[,\"dex\"]==\"treated\",]\ntreated.counts <- counts[ ,treated$id]\ntreated.mean <- rowSums( treated.counts )/4 \nhead(treated.mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nENSG00000000003 ENSG00000000005 ENSG00000000419 ENSG00000000457 ENSG00000000460 \n         658.00            0.00          546.00          316.50           78.75 \nENSG00000000938 \n           0.00 \n```\n:::\n:::\n\n\n**Q5 (a).** Create a scatter plot showing the mean of the treated samples against the mean of the control samples. Your plot should look something like the following.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmeancounts <- data.frame(control.mean, treated.mean)\ncolSums(meancounts)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncontrol.mean treated.mean \n    23005324     22196524 \n```\n:::\n\n```{.r .cell-code}\n# Plot both means by plotting \nplot(meancounts[,1],meancounts[,2], xlab=\"Control\", ylab=\"Treated\")\n```\n\n::: {.cell-output-display}\n![](Class12_files/figure-pdf/unnamed-chunk-7-1.pdf){fig-pos='H'}\n:::\n:::\n\n\nTo calculate the log2 of the fold change between treated and control...\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmeancounts$log2fc <- log2(meancounts$treated.mean/ meancounts$control.mean)\n```\n:::\n\n\n**Q7.** What is the purpose of the `arr.ind` argument in the **which()** function call above? Why would we then take the first column of the output and need to call the **unique()** function?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nzero.vals<- which(meancounts[, 1:2]==0, arr.ind =TRUE)\nto.rm<- unique(zero.vals[,1])\nmycounts<- meancounts[-to.rm]\n```\n:::\n\n\nThe arr.ind is important because it returns the indexes of the values that are TRUE. We take the first column from this and return the non repeating or unique indexes.\n\n**Q8.** Using the `up.ind` vector above can you determine how many up regulated genes we have at the greater than 2 fc level?\n\n250\n\n**Q9.** Using the `down.ind` vector above can you determine how many down regulated genes we have at the greater than 2 fc level?\n\n367\n\n**Q10.** Do you trust these results? Why or why not?\n\nThere is lots of documentation for existing functions such as the DESeq2 class that we can use to run statistical analysis/functions rather than doing it by hand and getting human errors.\n\n# DESeq2 Analysis\n\nFirst step, loading the library\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary('DESeq2')\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: S4Vectors\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: stats4\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: BiocGenerics\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'BiocGenerics'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    IQR, mad, sd, var, xtabs\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    anyDuplicated, aperm, append, as.data.frame, basename, cbind,\n    colnames, dirname, do.call, duplicated, eval, evalq, Filter, Find,\n    get, grep, grepl, intersect, is.unsorted, lapply, Map, mapply,\n    match, mget, order, paste, pmax, pmax.int, pmin, pmin.int,\n    Position, rank, rbind, Reduce, rownames, sapply, setdiff, sort,\n    table, tapply, union, unique, unsplit, which.max, which.min\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'S4Vectors'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    expand.grid, I, unname\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: IRanges\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: GenomicRanges\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: GenomeInfoDb\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: SummarizedExperiment\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: MatrixGenerics\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: matrixStats\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'MatrixGenerics'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:matrixStats':\n\n    colAlls, colAnyNAs, colAnys, colAvgsPerRowSet, colCollapse,\n    colCounts, colCummaxs, colCummins, colCumprods, colCumsums,\n    colDiffs, colIQRDiffs, colIQRs, colLogSumExps, colMadDiffs,\n    colMads, colMaxs, colMeans2, colMedians, colMins, colOrderStats,\n    colProds, colQuantiles, colRanges, colRanks, colSdDiffs, colSds,\n    colSums2, colTabulates, colVarDiffs, colVars, colWeightedMads,\n    colWeightedMeans, colWeightedMedians, colWeightedSds,\n    colWeightedVars, rowAlls, rowAnyNAs, rowAnys, rowAvgsPerColSet,\n    rowCollapse, rowCounts, rowCummaxs, rowCummins, rowCumprods,\n    rowCumsums, rowDiffs, rowIQRDiffs, rowIQRs, rowLogSumExps,\n    rowMadDiffs, rowMads, rowMaxs, rowMeans2, rowMedians, rowMins,\n    rowOrderStats, rowProds, rowQuantiles, rowRanges, rowRanks,\n    rowSdDiffs, rowSds, rowSums2, rowTabulates, rowVarDiffs, rowVars,\n    rowWeightedMads, rowWeightedMeans, rowWeightedMedians,\n    rowWeightedSds, rowWeightedVars\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: Biobase\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWelcome to Bioconductor\n\n    Vignettes contain introductory material; view with\n    'browseVignettes()'. To cite Bioconductor, see\n    'citation(\"Biobase\")', and for packages 'citation(\"pkgname\")'.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'Biobase'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following object is masked from 'package:MatrixGenerics':\n\n    rowMedians\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:matrixStats':\n\n    anyMissing, rowMedians\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Love, M.I., Huber, W., Anders, S. Moderated estimation of fold change and dispersion for RNA-seq data with DESeq2 Genome Biology 15(12):550 (2014)\ncitation('DESeq2')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nTo cite package 'DESeq2' in publications use:\n\n  Love, M.I., Huber, W., Anders, S. Moderated estimation of fold change\n  and dispersion for RNA-seq data with DESeq2 Genome Biology 15(12):550\n  (2014)\n\nA BibTeX entry for LaTeX users is\n\n  @Article{,\n    title = {Moderated estimation of fold change and dispersion for RNA-seq data with DESeq2},\n    author = {Michael I. Love and Wolfgang Huber and Simon Anders},\n    year = {2014},\n    journal = {Genome Biology},\n    doi = {10.1186/s13059-014-0550-8},\n    volume = {15},\n    issue = {12},\n    pages = {550},\n  }\n```\n:::\n:::\n\n\nLet's generate the specific object that DESeq2 needs:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Id needs to be Col Names. We use DEX to define the subgroups\ndds <- DESeqDataSetFromMatrix(countData = counts, \n                              colData = metadata, \n                              design= ~dex)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nconverting counts to integer mode\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in DESeqDataSet(se, design = design, ignoreRank): some variables in\ndesign formula are characters, converting to factors\n```\n:::\n\n```{.r .cell-code}\ndds\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass: DESeqDataSet \ndim: 38694 8 \nmetadata(1): version\nassays(1): counts\nrownames(38694): ENSG00000000003 ENSG00000000005 ... ENSG00000283120\n  ENSG00000283123\nrowData names(0):\ncolnames(8): SRR1039508 SRR1039509 ... SRR1039520 SRR1039521\ncolData names(4): id dex celltype geo_id\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndds <- DESeq(dds)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nestimating size factors\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nestimating dispersions\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\ngene-wise dispersion estimates\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nmean-dispersion relationship\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nfinal dispersion estimates\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nfitting model and testing\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#Show us the results of the statistical analysis \nres <- results(dds)\nres\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nlog2 fold change (MLE): dex treated vs control \nWald test p-value: dex treated vs control \nDataFrame with 38694 rows and 6 columns\n                 baseMean log2FoldChange     lfcSE      stat    pvalue\n                <numeric>      <numeric> <numeric> <numeric> <numeric>\nENSG00000000003  747.1942     -0.3507030  0.168246 -2.084470 0.0371175\nENSG00000000005    0.0000             NA        NA        NA        NA\nENSG00000000419  520.1342      0.2061078  0.101059  2.039475 0.0414026\nENSG00000000457  322.6648      0.0245269  0.145145  0.168982 0.8658106\nENSG00000000460   87.6826     -0.1471420  0.257007 -0.572521 0.5669691\n...                   ...            ...       ...       ...       ...\nENSG00000283115  0.000000             NA        NA        NA        NA\nENSG00000283116  0.000000             NA        NA        NA        NA\nENSG00000283119  0.000000             NA        NA        NA        NA\nENSG00000283120  0.974916      -0.668258   1.69456 -0.394354  0.693319\nENSG00000283123  0.000000             NA        NA        NA        NA\n                     padj\n                <numeric>\nENSG00000000003  0.163035\nENSG00000000005        NA\nENSG00000000419  0.176032\nENSG00000000457  0.961694\nENSG00000000460  0.815849\n...                   ...\nENSG00000283115        NA\nENSG00000283116        NA\nENSG00000283119        NA\nENSG00000283120        NA\nENSG00000283123        NA\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(res)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nout of 25258 with nonzero total read count\nadjusted p-value < 0.1\nLFC > 0 (up)       : 1563, 6.2%\nLFC < 0 (down)     : 1188, 4.7%\noutliers [1]       : 142, 0.56%\nlow counts [2]     : 9971, 39%\n(mean count < 10)\n[1] see 'cooksCutoff' argument of ?results\n[2] see 'independentFiltering' argument of ?results\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#Change the alpha from default of 0.1 to 0.05\nres05 <- results(dds, alpha=0.05)\nsummary(res05)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nout of 25258 with nonzero total read count\nadjusted p-value < 0.05\nLFC > 0 (up)       : 1236, 4.9%\nLFC < 0 (down)     : 933, 3.7%\noutliers [1]       : 142, 0.56%\nlow counts [2]     : 9033, 36%\n(mean count < 6)\n[1] see 'cooksCutoff' argument of ?results\n[2] see 'independentFiltering' argument of ?results\n```\n:::\n:::\n",
    "supporting": [
      "Class12_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}